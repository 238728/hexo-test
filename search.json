[{"title":"OI中“诈骗题”简述","path":"/2024/10/02/dpahtst/","content":"诈骗犯，带走！ 写在前面 由于是诈骗题，建议先思考一遍题目。 题目一 对于一个序列 a[l,r]a_{[l,r]}a[l,r]​，定义它的 Mex 变换 b[l,r]b_{[l,r]}b[l,r]​ 如下： 对于每一个 l≤i≤rl \\leq i \\leq rl≤i≤r，有 bi=mex({al,al+1,⋯ ,ai−1,ai+1,⋯ ,ar−1,ar})b_i=\\text{mex}(\\{a_l,a_{l+1},⋯ ,a_{i−1},a_{i+1},⋯ ,a_{r−1},a_r\\})bi​=mex({al​,al+1​,⋯ ,ai−1​,ai+1​,⋯ ,ar−1​,ar​})。 给定一个长度为 nnn 的序列 a[1,n]​a_{[1,n]}​a[1,n]​​，你每次操作可以选择一个区间，并将这个区间替换为它的 Mex 变换。 你最多可以进行 kkk 次操作，你需要最小化操作完成后序列的字典序。构造任意方案。注意：你并不需要最小化你的操作次数。 输入格式 第一行两个整数 n,kn,kn,k。 接下来一行 nnn 个整数，表示序列 a[1,n]a_{[1,n]}a[1,n]​。 输出格式 第一行输出一个整数 mmm 表示你使用的操作次数。 接下来 mmm 行，每行输出两个整数，表示你依次操作的每一个区间。 样例 输入1 124 30 1 2 3 输出1 123432 23 34 4 输入2 126 10 1 2 0 3 4 输出2 1212 3 数据范围 1≤n,k≤1051 \\leq n,k \\leq 10^51≤n,k≤105，0≤ai≤n0 \\leq a_i \\leq n0≤ai​≤n。 解答先思考：mex\\text{mex}mex 运算有什么性质？A⊂[1,+∞)∩Z,mex(A)=0A \\subset [1,+\\infty) \\cap \\mathbb{Z},\\text{mex}(A)=0A⊂[1,+∞)∩Z,mex(A)=0。人话：如果一个集合中所有数都 &gt;0&gt;0&gt;0，则这个集合的 mex\\text{mex}mex 值一定为 000。0∈A,mex(A)≥10 \\in A,\\text{mex}(A) \\geq 10∈A,mex(A)≥1。人话：如果一个集合中有 000，则这个集合的 mex\\text{mex}mex 值一定 ≥1\\geq 1≥1。此题仅仅用到以上两个性质。记 a[1,n]​a_{[1,n]}​a[1,n]​​ 中 000 的数量为 xxx。当 k=1k=1k=1 时，也就是最多只能做一次操作。当 x=0x=0x=0 时，答案为 111。对 a[1,n]a_{[1,n]}a[1,n]​ 做一次变换即可。当 x=nx=nx=n 时，答案为 000。本来数列就全零，不需要操作。其他情况下，答案为 111。记 a[1,n]​a_{[1,n]}​a[1,n]​​ 中从左到右第一个最大连续非零区间为 a[u,v]a_{[u,v]}a[u,v]​，对 a[u,v]a_{[u,v]}a[u,v]​ 做一次变换即可。其他情况下，讨论 xxx 的大小。当 x=0x=0x=0 时，答案为 111。对 a[1,n]a_{[1,n]}a[1,n]​ 做一次变换即可。当 x=1x=1x=1 时，记这一个 000 的下标为 qqq。先对 a[1,q−1]a_{[1,q-1]}a[1,q−1]​ 做一次变换，再对 a[q+1,n]a_{[q+1,n]}a[q+1,n]​ 做一次变换即可。答案为 111 或 222。当 x≥2x \\geq 2x≥2 时，答案其实是 222。具体过程是先对 a[1,n]a_{[1,n]}a[1,n]​ 做一次变换，再对 a[1,n]a_{[1,n]}a[1,n]​ 做一次变换。第一次变换会将所有数变为 ≥1\\geq 1≥1 的数，而第二次变换则会将所有数变为 000。 评价名副其实的诈骗题。题目中说”输出任意方案“让人摸不着头脑，样例中又给了奇奇怪怪的输出。第一眼会想打暴力分，可是暴力很长，一般都写不对。看了解答后才会大呼一声：”原来如此！“真是防不甚防。","tags":["OI-题目","反思"]},{"title":"洛谷 P7991 做题记录","path":"/2024/09/27/LG-P7991/","content":"P7991 [USACO21DEC] Connecting Two Barns S 思路 并查集+二分查找 以下假设点 iii 所在的连通块的点集为 GiG_iGi​。有可能存在 Gu=GvG_u=G_vGu​=Gv​。 具体做法是分类讨论： 不连边，则必须保证 G1=GnG_1=G_nG1​=Gn​。 连一条边，则在分别在 G1G_1G1​ 和 GnG_nGn​ 中找一点连边。 连两条边，则寻找一点 xxx。接着在 GxG_xGx​ 中枚举一点 yyy。将 yyy 与 G1G_1G1​ 中一点连边，再将 yyy 与 GnG_nGn​ 中一点连边。 接下来定义一个函数：cost(u,v)cost(u,v)cost(u,v)。它的操作就是在 GuG_uGu​ 中枚举一点 yyy。将 yyy 与 GvG_vGv​ 中一点连边的最小代价。 连边操作可以通过二分查找与 yyy 权值差最小的点 O(log⁡n)O(\\log{n})O(logn) 实现。 所以，上述所有情况都可归为：枚举一点 xxx，代价和就是 cost(1,x)+cost(x,n)cost(1,x)+cost(x,n)cost(1,x)+cost(x,n)。算出所有代价和，取最小值即为答案。可以这样做的具体原因请读者自行思考。 注意因为此题数据有些特殊，必须保证程序的时间复杂度是 O(nlog⁡n)O(n \\log{n})O(nlogn)。只需稍稍修改一下 cost(u,v)cost(u,v)cost(u,v) 函数，保证在较小的块中枚举，和较大的块中的点连边即可。我就是这样50分的 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,fa[1000005];void init()&#123;\tfor(int i=1;i&lt;=n;i++)\t&#123; fa[i]=i;\t&#125;&#125;long long find(long long x)&#123;\tif(fa[x]==x)\t&#123; return x;\t&#125;\telse\t&#123; return fa[x]=find(fa[x]);\t&#125;&#125;void merge(long long x,long long y)&#123;\tx=find(x);\ty=find(y);\tif(x!=y)\t&#123; fa[x]=y;\t&#125;&#125;long long dist(long long c,long long d)&#123;\treturn (c-d)*(c-d);&#125;vector&lt;long long&gt;dot[1000005];long long cost(long long fx,long long fy)&#123;\tif(dot[fx].size()&gt;dot[fy].size())\t&#123; swap(fx,fy);\t&#125;//不加会TLE 50pts\tlong long res=1e18;\tfor(int i=0;i&lt;dot[fx].size();i++)\t&#123; long long u=dot[fx][i]; long long bg=lower_bound(dot[fy].begin(),dot[fy].end(),u)-dot[fy].begin(); //bg=[0,dot[fy].size()] if(bg&gt;0) &#123; long long v=dot[fy][bg-1]; res=min(res,dist(u,v)); &#125; if(bg&lt;dot[fy].size()) &#123; long long v=dot[fy][bg]; res=min(res,dist(u,v)); &#125;\t&#125;\treturn res;&#125;int main()&#123;\tlong long t;\tcin&gt;&gt;t;\twhile(t--)\t&#123; cin&gt;&gt;n&gt;&gt;m; init(); for(int i=1;i&lt;=n;i++) &#123; dot[i].clear(); &#125; for(int i=1;i&lt;=m;i++) &#123; long long x,y; cin&gt;&gt;x&gt;&gt;y; merge(x,y); &#125; for(int i=1;i&lt;=n;i++) &#123; long long tmp=find(i); dot[tmp].push_back(i); &#125; long long ans=1e18; long long st=find(1),ed=find(n); for(int i=1;i&lt;=n;i++) &#123; ans=min(ans,cost(st,i)+cost(ed,i)); &#125; cout&lt;&lt;ans&lt;&lt;endl;\t&#125;\t&#125;","tags":["OI-题目"]}]