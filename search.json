[{"title":"洛谷 P7991 做题记录","path":"/2024/09/27/P7991/","content":"P7991 [USACO21DEC] Connecting Two Barns S 思路 并查集+二分查找 以下假设点 iii 所在的连通块的点集为 GiG_iGi​。有可能存在 Gu=GvG_u=G_vGu​=Gv​。 具体做法是分类讨论： 不连边，则必须保证 G1=GnG_1=G_nG1​=Gn​。 连一条边，则在分别在 G1G_1G1​ 和 GnG_nGn​ 中找一点连边。 连两条边，则寻找一点 xxx。接着在 GxG_xGx​ 中枚举一点 yyy。将 yyy 与 G1G_1G1​ 中一点连边，再将 yyy 与 GnG_nGn​ 中一点连边。 接下来定义一个函数：cost(u,v)cost(u,v)cost(u,v)。它的操作就是在 GuG_uGu​ 中枚举一点 yyy。将 yyy 与 GvG_vGv​ 中一点连边的最小代价。 连边操作可以通过二分查找与 yyy 权值差最小的点 O(log⁡n)O(\\log{n})O(logn) 实现。 所以，上述所有情况都可归为：枚举一点 xxx，代价和就是 cost(1,x)+cost(x,n)cost(1,x)+cost(x,n)cost(1,x)+cost(x,n)。算出所有代价和，取最小值即为答案。可以这样做的具体原因请读者自行思考。 注意因为此题数据有些特殊，必须保证程序的时间复杂度是 O(nlog⁡n)O(n \\log{n})O(nlogn)。在 cost(u,v)cost(u,v)cost(u,v) 函数中，一定要在较小的块中枚举，和较大的块中的点连边。我就是这样50分的 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,fa[1000005];void init()&#123;\tfor(int i=1;i&lt;=n;i++)\t&#123; fa[i]=i;\t&#125;&#125;long long find(long long x)&#123;\tif(fa[x]==x)\t&#123; return x;\t&#125;\telse\t&#123; return fa[x]=find(fa[x]);\t&#125;&#125;void merge(long long x,long long y)&#123;\tx=find(x);\ty=find(y);\tif(x!=y)\t&#123; fa[x]=y;\t&#125;&#125;long long dist(long long c,long long d)&#123;\treturn (c-d)*(c-d);&#125;vector&lt;long long&gt;dot[1000005];long long cost(long long fx,long long fy)&#123;\tif(dot[fx].size()&gt;dot[fy].size())\t&#123; swap(fx,fy);\t&#125;\tlong long res=1e18;\tfor(int i=0;i&lt;dot[fx].size();i++)\t&#123; long long u=dot[fx][i]; long long bg=lower_bound(dot[fy].begin(),dot[fy].end(),u)-dot[fy].begin(); //bg=[0,dot[fy].size()] if(bg&gt;0) &#123; long long v=dot[fy][bg-1]; res=min(res,dist(u,v)); &#125; if(bg&lt;dot[fy].size()) &#123; long long v=dot[fy][bg]; res=min(res,dist(u,v)); &#125;\t&#125;\treturn res;&#125;int main()&#123;\tlong long t;\tcin&gt;&gt;t;\twhile(t--)\t&#123; cin&gt;&gt;n&gt;&gt;m; init(); for(int i=1;i&lt;=n;i++) &#123; dot[i].clear(); &#125; for(int i=1;i&lt;=m;i++) &#123; long long x,y; cin&gt;&gt;x&gt;&gt;y; merge(x,y); &#125; for(int i=1;i&lt;=n;i++) &#123; long long tmp=find(i); dot[tmp].push_back(i); &#125; long long ans=1e18; long long st=find(1),ed=find(n); for(int i=1;i&lt;=n;i++) &#123; ans=min(ans,cost(st,i)+cost(ed,i)); &#125; cout&lt;&lt;ans&lt;&lt;endl;\t&#125;\t&#125; A B C x y z u v w","tags":["OI-题目"]},{"title":"测试Markdown文章","path":"/2024/07/05/mathtest_latex/","content":"这是一篇用来测试Markdown与LaTeX功能的文章。 Markdown H1 H2 H3 H4 H5 H6 加粗划掉正常 链接 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\tlong long a,b;\tcin&gt;&gt;a&gt;&gt;b;\tcout&lt;&lt;a+b&lt;&lt;&quot; &quot;&lt;&lt;max(a,b)&lt;&lt;endl;\treturn 0;&#125; LaTeX ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ} ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ\\large{ABCDEFGHIJKLMNOPQRSTUVWXYZ} ABCDEFGHIJKLMNOPQRSTUVWXYZ ABΓΔEZHΘIKΛMNΞOΠPΣTΥΦXΨΩ\\Alpha\\Beta\\Gamma\\Delta\\Epsilon\\Zeta\\Eta\\Theta\\Iota\\Kappa\\Lambda\\Mu\\Nu\\Xi\\Omicron\\Pi\\Rho\\Sigma\\Tau\\Upsilon\\Phi\\Chi\\Psi\\Omega ABΓΔEZHΘIKΛMNΞOΠPΣTΥΦXΨΩ αβγδϵζηθικλμνξοπρστυϕχψω\\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta\\iota\\kappa\\lambda\\mu u\\xi\\omicron\\pi\\rho\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega αβγδϵζηθικλμνξοπρστυϕχψω G=∑i=0n(ni)=2nG=\\sum_{i=0}^n \\binom{n}{i}=2^n G=i=0∑n​(in​)=2n H=∑i=0n(i⋅(ni))=n⋅2n−1H=\\sum_{i=0}^n (i \\cdot \\binom{n}{i})=n \\cdot 2^{n-1} H=i=0∑n​(i⋅(in​))=n⋅2n−1 你好\\textup{你好} 你好 Hello\\text{Hello} Hello For equations like this: ax2+bx+c=0, we have: x1,2=−b±b2−4ac2a\\text{For equations like this: }ax^2+bx+c=0 \\text{, we have: }x_{1,2}=\\dfrac{-b \\pm \\sqrt{b^2-4ac}}{2a} For equations like this: ax2+bx+c=0, we have: x1,2​=2a−b±b2−4ac​​","tags":["测试"]},{"title":"关于","path":"/about/index.html","content":"About me. Under construction…"}]